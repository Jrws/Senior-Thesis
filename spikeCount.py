import numpy as np
import argparse
from scipy import stats as sts, signal as sig
from matplotlib import pyplot as plt
from neo import io
import re
import os
import openpyxl as px

from functions import *

### TODO: Tune autogenerated histogram bounds
    # doesn't work well for super strong signals, shrinking signals, Ex. Odor43
    # use non-unique counts for bounds?
### TODO: save spike files, run program to edit bounds

# To run:
# > python spikeCount.py "SSR files/Nov1"

USER_ADJUST = True
KEEP_LAST_BOUNDS = False
DIGITAL_SIGNAL_TIME = 3.18       # Extract from digital signal file? or just set
marker_left = DIGITAL_SIGNAL_TIME - 0.5
marker_right = DIGITAL_SIGNAL_TIME + 0.5

# Parse file name argument by running script from command line
parser = argparse.ArgumentParser("Analyzes spike counts from data")
parser.add_argument('folder', help="Specifies folder to be processed")
args = parser.parse_args()      # only arg is path to folder
if not os.path.isdir(args.folder):
    raise SystemExit(f'File {args.folder} not found!')

### CHANGE FILE PATH BELOW TO SPECIFY INPUT
asc_dir = args.folder
#asc_dir = 'SSR files/Nov1'

output = os.path.join(asc_dir, 'deltaSpikes.xlsx')
header = ['signal_number', 'delta_A_spikes', 'delta_B_spikes', 'diff_time', 'before_left_bound', 'before_right_bound', 'after_left_bound', 'after_right_bound']
if not os.path.isfile(output):
    wb = px.Workbook()
    wb.active.append(header)
    wb.save(output)
    wb.close()
else:
    try:
        wb = px.load_workbook(output)
        sheet = wb.active
        if not sheet.cell(1, 1).value:
            for j in range(1,9):
                sheet.cell(1,j).value = header[j-1]
            wb.save(output)
            wb.close()
        wb.save(output)
        wb.close()

    except:
        print('No permission to write to output file, try closing it in Excel.')
        exit()

with open(os.path.join(asc_dir, 'signalsToTest.txt'), 'r') as f:
    signalNums = f.read().splitlines()

class_bounds = []

sigNumInd = 0
while sigNumInd < len(signalNums):       # file conversions
    sigNum = signalNums[sigNumInd]
    print(f'Signal: {sigNum}')
    trace_ascii = os.path.join(asc_dir, 'ascii', sigNum + '.asc')
    with open(trace_ascii, 'r') as a:
        for line in a:
            if line.startswith('; Sample rate'):
                sampleRate = float(line.split(' ')[-1])
                break

    # Import analog signal from nix file as a 1D array, and generate the corresponding time scale from the sampling frequency
    trace = np.array(io.NixIO(os.path.join(asc_dir, 'nix', sigNum + '.nix'), mode='ro').read_block().segments[0].analogsignals[0]).T[0]
    trace_x = (np.array(np.arange(trace.size)) / sampleRate)
    # Calculate the spikes from the trace, store spike times in x and spike magnitudes in y
    spikes = toSpikes(trace, sampleRate)

    # # Plotting traces with spikes overlaid
    # plt.plot(trace_x, trace, color='gray')
    # plotSpikes(spikes, 'blue')
    # plt.show()

    # Plotting histogram of spike distribution
    h,e = np.histogram(spikes[1], bins=32, density=True)
    x = np.linspace(e.min(), e.max())
    kde = sts.gaussian_kde(spikes[1], bw_method=0.05)
    y = kde.pdf(x)
    max_inds = np.array(sig.argrelmax(y))[0]
    max_pos, max_counts = x[max_inds], y[max_inds]
    top3_inds = np.sort(np.argpartition(max_counts,-3)[-3:])        # may need to adjust if one of the spike classes has a high bimodal peak
    max_inds, max_pos, max_counts = max_inds[top3_inds], max_pos[top3_inds], max_counts[top3_inds]
    if len(class_bounds) == 0 or not KEEP_LAST_BOUNDS:
        class_bounds = np.array([x[max_inds[i % 2] + np.argmin(y[max_inds[i % 2]:max_inds[(i % 2)+1]])] for i in range(4)])     # bound is the min between the two max peaks
        
        ###  class_bounds = np.array([x[int((max_inds[0] * 2))],         # boundary between first and second peak is the distance the first peak is from 0 reflected
        #                           x[max_inds[1] + np.argmin(y[max_inds[1]:max_inds[2]])]])
        
        ### boundary between noise and first peak is the min, margin between first and second peak is proportional to ratio of to peak heights
        # bound_left = x[int(max_inds[0] + np.argmin(y[max_inds[0]:max_inds[1]]))]
        # bound_right = x[int(max_inds[1] + (max_counts[1]/max_counts[2]) * (max_inds[2] - max_inds[1]) )]
        # class_bounds = np.array([bound_left, bound_right, bound_left, bound_right]) # before_left, before_right, after_left, after_right

    hist_centers = (e[:-1] + e[1:]) / 2
    hist_width = np.diff(e)
    y_max = np.max(y)

    before_colors = ('blue','orange')
    after_colors = ('darkblue','coral')

    def plotSpikeDistrib(after):
        plt.plot(x, y)  # plot KDE smoothed curve
        plt.bar(hist_centers, h, align='center', width=hist_width)      # plot initial underlying histogram for spike distribution
        plt.ylim(0,max_counts[2] * 2)
        if not after:
            leftBound, rightBound = class_bounds[0], class_bounds[1]
            colorB, colorA = before_colors
            plotVlines(class_bounds[:2], color='red')
        else:
            leftBound, rightBound = class_bounds[2], class_bounds[3]
            colorB, colorA = after_colors
            plotVlines(class_bounds[2:], color='red')
        plt.axvspan(0, leftBound, alpha=0.3, color='black', lw=0)     # region of excluded spikes
        plt.axvspan(leftBound, rightBound, alpha=0.3, color=colorB, lw=0)      # region of B neuron spikes before
        plt.axvspan(rightBound, e.max(), alpha=0.3, color=colorA, lw=0)       # region of A neuron spikes before
        #plotVlines(max_pos, color='black', linestyle='dashed')     # identify maxes used
        

    plt.subplot(312)
    plotSpikeDistrib(False)
    plt.subplot(313)
    plotSpikeDistrib(True)

    spikeClasses = []

    def plotSpikeRegion():
        range_spikes = spikesInRange(spikes, marker_left, marker_right, 0, np.inf)
        before_spikes_B = spikesInRange(spikes, marker_left, DIGITAL_SIGNAL_TIME, class_bounds[0], class_bounds[1])
        after_spikes_B = spikesInRange(spikes, DIGITAL_SIGNAL_TIME, marker_right, class_bounds[2], class_bounds[3])
        before_spikes_A = spikesInRange(spikes, marker_left, DIGITAL_SIGNAL_TIME, class_bounds[1], np.inf)
        after_spikes_A = spikesInRange(spikes, DIGITAL_SIGNAL_TIME, marker_right, class_bounds[3], np.inf)
        plotSpikes(range_spikes, 'gray')
        plotSpikes(before_spikes_A, before_colors[1])
        plotSpikes(before_spikes_B, before_colors[0])
        plotSpikes(after_spikes_A, after_colors[1])
        plotSpikes(after_spikes_B, after_colors[0])        
        plotVlines([DIGITAL_SIGNAL_TIME], color='black', linestyle='dotted')
        global spikeClasses
        spikeClasses = [before_spikes_B, after_spikes_B, before_spikes_A, after_spikes_A]

    def replot():
        plt.clf()
        plt.subplot(312)
        plotSpikeDistrib(False)
        plt.subplot(313)
        plotSpikeDistrib(True)
        plt.subplot(311)
        plotSpikeRegion()
        plt.savefig(os.path.join(asc_dir, 'plt', sigNum + '.png'))
        if USER_ADJUST:
            plt.show(block=False)

    plt.subplot(311)
    plotSpikeRegion()
    
    plt.savefig(os.path.join(asc_dir, 'plt', sigNum + '.png'))
    if USER_ADJUST:
        plt.show(block=False)

    IS_NUMBER = r"^[-+]?[0-9]*\.?[0-9]+$"

    change_sig = 0
    if USER_ADJUST:
        while True:     #TODO: Check more restrictions like second bound after first
            side = input("Command (to show all commands, type HELP): ").lower()
            if side == 'help':
                print("""
                      A\t\tEdit spike boundaries after the signal time, will prompt for left/right boundary and new position
                      B\t\tEdit spike boundaries before the signal time, will prompt for left/right boundary and new position
                      C\t\tConfirms spike boundaries, saves data for current signal, and moves on to next signal
                      
                      AUTO\tAnalyzes the rest of the data automatically using the spike boundary calculation algorithm (not recommended, not very accurate)
                      BACK\tGoes to previous signal without storing new data for current signal
                      EXIT\tQuits the program without storing any new data for the current signal
                      HELP\tShows this list of commnds
                      KEEP\tInstead of recalculating the bounds for the next signal, keep the same boundaries as the current signal
                      NEXT\tGoes to next signal without storing new data for current signal
                      SKIP\tSame as NEXT
                      TIME\tPrompts for adjusting the signal time that the graphs are centered on

                      * commands are not case sensitive
                """)
            elif side == 'auto':
                USER_ADJUST = False
                break
            elif side == 'keep':
                KEEP_LAST_BOUNDS = not KEEP_LAST_BOUNDS
                print(f'KEEP_LAST_BOUNDS = {KEEP_LAST_BOUNDS}')
                continue
            elif side == 'next' or side == 'skip':
                change_sig = 1
                break
            elif side == 'back':
                change_sig = -1
                break
            elif side == 'exit':
                exit()
            elif side == 'time':
                new_time = input("New signal time: ")
                if re.match(IS_NUMBER, new_time):
                    new_time = float(new_time)
                    if new_time < trace_x[-1] - 0.5 and new_time > 0.5:
                        DIGITAL_SIGNAL_TIME = float(new_time)
                        marker_left = DIGITAL_SIGNAL_TIME - 0.5
                        marker_right = DIGITAL_SIGNAL_TIME + 0.5
                        plt.clf()
                        replot()
                    else:
                        print('Time +- 0.5 seconds not in range')
                    continue
                else:
                    print('Invalid input: not a float')
                    continue
            elif side in ['b','a']:
                bound = input("Left or right? (l/r) ")
                if bound in ['l','r']:
                    while True:
                        new_loc = input("Position (based on histogram x-axes): ")
                        if re.match(IS_NUMBER, new_loc):
                                new_loc = float(new_loc)
                                if new_loc > x.max():
                                    new_loc = x.max()
                                if new_loc < 0:
                                    new_loc = 0
                                class_bounds['b_a_'.index(side) + 'lr'.index(bound)] = new_loc
                                replot()
                        else:
                            break
            elif side == 'c':
                break
            else:
                print("Unknown command, type HELP to show list of commands")
        
    plt.clf()
    if change_sig == 1:
        sigNumInd += 1
        if sigNumInd >= len(signalNums):
            break
        else:
            continue
    elif change_sig == -1:
        sigNumInd -= 1
        if sigNumInd < 0:
            break
        else:
            continue

    # spike_counts: [before_count_B, after_count_B, before_count_A, after_count_A]
    spike_counts = [spikes.shape[1] if spikes.size > 0 else 0 for spikes in spikeClasses]

    delta_spikes_A = (spike_counts[3] - spike_counts[2]) * 2    # change in spikes / 1 second
    delta_spikes_B = (spike_counts[1] - spike_counts[0]) * 2
    print('Delta spikes A:', delta_spikes_A)
    print('Delta spikes B:', delta_spikes_B)
    
    wb = px.load_workbook(output)
    sheet = wb.active
    row = [sigNum, delta_spikes_A, delta_spikes_B, DIGITAL_SIGNAL_TIME, class_bounds[0], class_bounds[1], class_bounds[2], class_bounds[3]]
    found = False
    for i in range(2,sheet.max_row + 1):
        if sheet.cell(i, 1).value == sigNum:
            for j in range(1,9):
                sheet.cell(i,j).value = row[j-1]
            wb.save(output)
            wb.close()
            found = True
            break
    if not found:
        sheet.append(row)
        wb.save(output)
        wb.close()
    
    sigNumInd += 1